% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/math-basic.R
\name{remainder}
\alias{remainder}
\alias{rray_fmod}
\alias{rray_remainder}
\title{Remainders}
\usage{
rray_fmod(x, y)

rray_remainder(x, y)
}
\arguments{
\item{x, y}{A vector, matrix, array or rray.}
}
\description{
\itemize{
\item \code{rray_fmod()} computes the element-wise remainder of the floating point
division of \code{x / y}.
\item \code{rray_remainder()} computes the IEEE element-wise remainder of the
floating point division of \code{x / y}.
}
}
\details{
\itemize{
\item \code{rray_fmod()} - The floating-point remainder of the division operation
\code{x / y} calculated by this function is exactly the value \code{x - n * y}, where
\code{n} is \code{x / y} with its fractional part truncated.
\item \code{rray_remainder()} - The IEEE floating-point remainder of the division
operation \code{x / y} calculated by this function is exactly the
value \code{x - n * y}, where the value \code{n} is the integral value nearest the
exact value \code{x / y}. When \code{|n - x / y| = 1/2}, the value \code{n} is chosen
to be even. In contrast to \code{rray_fmod()}, the returned value is not
guaranteed to have the same sign as \code{x}.
}
}
\examples{
rray_fmod(1, 2)
rray_remainder(1, 2)

# Always same sign as `x`
# 2 / 3 = 0.667 -> n = 0
# (2 - 0 * 3) = 2
rray_fmod(2, 3)

# No guarantee of same sign as `x`
# 2 / 3 = 0.667 -> n = 1
# (2 - 1 * 3) = -1
rray_remainder(2, 3)

# 12 / 8 = 1.5 -> n = 2 or 1?
# This is the `|n - x / y| = 1/2` case
# Chosen to be n = 2, i.e. even, by convention.
# (12 - 2 * 8) = -4
rray_remainder(12, 8)

# Broadcasts appropriately
x <- matrix(1:5)
rray_remainder(x, t(x))

# Be aware of the limits of floating
# point arithmetic!
# 1 / .2 = 5 -> n = 5
# (1 - 5 * .2) = 0
# I get -5.551115e-17
rray_remainder(1, .2)

# More serious limitations with rray_fmod()
# 1 / .1 = 10 -> n = 10
# (1 - 10 * .1) = 0
# I get 0.1
rray_fmod(1, .1)

# ^ is due to the implementation of `std::fmod()`
# in C++. It is basically the following, which
# gives the incorrect 0.1:
x <- 1
y <- 0.1
x_abs <- abs(x)
y_abs <- abs(y)
# I get -5.551115e-17
result <- rray_remainder(x_abs, y_abs)
if (sign(result)) result <- result + y_abs
rray_abs(result) * sign(x)

}
\seealso{
Other math functions: \code{\link{rray_abs}},
  \code{\link{rray_clip}}, \code{\link{rray_maximum}},
  \code{\link{rray_multiply_add}}, \code{\link{rray_sign}}
}
\concept{math functions}
